# coding: utf-8

"""
    Shortcut API

    Shortcut API  # noqa: E501

    OpenAPI spec version: 3.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from shortcut_client_py.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_category(self, body, **kwargs):  # noqa: E501
        """Create Category  # noqa: E501

        Create Category allows you to create a new Category in Shortcut.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_category(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateCategory body: (required)
        :return: Category
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_category_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_category_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_category_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create Category  # noqa: E501

        Create Category allows you to create a new Category in Shortcut.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_category_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateCategory body: (required)
        :return: Category
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_category" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_category`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/categories', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Category',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_entity_template(self, body, **kwargs):  # noqa: E501
        """Create Entity Template  # noqa: E501

        Create a new entity template for the Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_entity_template(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateEntityTemplate body: Request paramaters for creating an entirely new entity template. (required)
        :return: EntityTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_entity_template_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_entity_template_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_entity_template_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create Entity Template  # noqa: E501

        Create a new entity template for the Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_entity_template_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateEntityTemplate body: Request paramaters for creating an entirely new entity template. (required)
        :return: EntityTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_entity_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_entity_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/entity-templates', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EntityTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_epic(self, body, **kwargs):  # noqa: E501
        """Create Epic  # noqa: E501

        Create Epic allows you to create a new Epic in Shortcut.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_epic(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateEpic body: (required)
        :return: Epic
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_epic_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_epic_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_epic_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create Epic  # noqa: E501

        Create Epic allows you to create a new Epic in Shortcut.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_epic_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateEpic body: (required)
        :return: Epic
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_epic" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_epic`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/epics', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Epic',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_epic_comment(self, body, epic_public_id, **kwargs):  # noqa: E501
        """Create Epic Comment  # noqa: E501

        This endpoint allows you to create a threaded Comment on an Epic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_epic_comment(body, epic_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateEpicComment body: (required)
        :param int epic_public_id: The ID of the associated Epic. (required)
        :return: ThreadedComment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_epic_comment_with_http_info(body, epic_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_epic_comment_with_http_info(body, epic_public_id, **kwargs)  # noqa: E501
            return data

    def create_epic_comment_with_http_info(self, body, epic_public_id, **kwargs):  # noqa: E501
        """Create Epic Comment  # noqa: E501

        This endpoint allows you to create a threaded Comment on an Epic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_epic_comment_with_http_info(body, epic_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateEpicComment body: (required)
        :param int epic_public_id: The ID of the associated Epic. (required)
        :return: ThreadedComment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'epic_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_epic_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_epic_comment`")  # noqa: E501
        # verify the required parameter 'epic_public_id' is set
        if ('epic_public_id' not in params or
                params['epic_public_id'] is None):
            raise ValueError("Missing the required parameter `epic_public_id` when calling `create_epic_comment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'epic_public_id' in params:
            path_params['epic-public-id'] = params['epic_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/epics/{epic-public-id}/comments', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ThreadedComment',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_epic_comment_comment(self, body, epic_public_id, comment_public_id, **kwargs):  # noqa: E501
        """Create Epic Comment Comment  # noqa: E501

        This endpoint allows you to create a nested Comment reply to an existing Epic Comment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_epic_comment_comment(body, epic_public_id, comment_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateCommentComment body: (required)
        :param int epic_public_id: The ID of the associated Epic. (required)
        :param int comment_public_id: The ID of the parent Epic Comment. (required)
        :return: ThreadedComment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_epic_comment_comment_with_http_info(body, epic_public_id, comment_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_epic_comment_comment_with_http_info(body, epic_public_id, comment_public_id, **kwargs)  # noqa: E501
            return data

    def create_epic_comment_comment_with_http_info(self, body, epic_public_id, comment_public_id, **kwargs):  # noqa: E501
        """Create Epic Comment Comment  # noqa: E501

        This endpoint allows you to create a nested Comment reply to an existing Epic Comment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_epic_comment_comment_with_http_info(body, epic_public_id, comment_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateCommentComment body: (required)
        :param int epic_public_id: The ID of the associated Epic. (required)
        :param int comment_public_id: The ID of the parent Epic Comment. (required)
        :return: ThreadedComment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'epic_public_id', 'comment_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_epic_comment_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_epic_comment_comment`")  # noqa: E501
        # verify the required parameter 'epic_public_id' is set
        if ('epic_public_id' not in params or
                params['epic_public_id'] is None):
            raise ValueError("Missing the required parameter `epic_public_id` when calling `create_epic_comment_comment`")  # noqa: E501
        # verify the required parameter 'comment_public_id' is set
        if ('comment_public_id' not in params or
                params['comment_public_id'] is None):
            raise ValueError("Missing the required parameter `comment_public_id` when calling `create_epic_comment_comment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'epic_public_id' in params:
            path_params['epic-public-id'] = params['epic_public_id']  # noqa: E501
        if 'comment_public_id' in params:
            path_params['comment-public-id'] = params['comment_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/epics/{epic-public-id}/comments/{comment-public-id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ThreadedComment',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_group(self, body, **kwargs):  # noqa: E501
        """Create Group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_group(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateGroup body: (required)
        :return: Group
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_group_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_group_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_group_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create Group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_group_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateGroup body: (required)
        :return: Group
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/groups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Group',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_iteration(self, body, **kwargs):  # noqa: E501
        """Create Iteration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_iteration(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateIteration body: (required)
        :return: Iteration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_iteration_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_iteration_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_iteration_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create Iteration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_iteration_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateIteration body: (required)
        :return: Iteration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_iteration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_iteration`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/iterations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Iteration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_label(self, body, **kwargs):  # noqa: E501
        """Create Label  # noqa: E501

        Create Label allows you to create a new Label in Shortcut.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_label(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateLabelParams body: Request parameters for creating a Label on a Shortcut Story. (required)
        :return: Label
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_label_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_label_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_label_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create Label  # noqa: E501

        Create Label allows you to create a new Label in Shortcut.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_label_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateLabelParams body: Request parameters for creating a Label on a Shortcut Story. (required)
        :return: Label
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_label" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_label`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/labels', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Label',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_linked_file(self, body, **kwargs):  # noqa: E501
        """Create Linked File  # noqa: E501

        Create Linked File allows you to create a new Linked File in Shortcut.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_linked_file(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateLinkedFile body: (required)
        :return: LinkedFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_linked_file_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_linked_file_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_linked_file_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create Linked File  # noqa: E501

        Create Linked File allows you to create a new Linked File in Shortcut.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_linked_file_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateLinkedFile body: (required)
        :return: LinkedFile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_linked_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_linked_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/linked-files', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LinkedFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_milestone(self, body, **kwargs):  # noqa: E501
        """Create Milestone  # noqa: E501

        Create Milestone allows you to create a new Milestone in Shortcut.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_milestone(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateMilestone body: (required)
        :return: Milestone
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_milestone_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_milestone_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_milestone_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create Milestone  # noqa: E501

        Create Milestone allows you to create a new Milestone in Shortcut.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_milestone_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateMilestone body: (required)
        :return: Milestone
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_milestone" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_milestone`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/milestones', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Milestone',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_multiple_stories(self, body, **kwargs):  # noqa: E501
        """Create Multiple Stories  # noqa: E501

        Create Multiple Stories allows you to create multiple stories in a single request using the same syntax as [Create Story](https://shortcut.com/api/#create-story).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_multiple_stories(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateStories body: (required)
        :return: list[StorySlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_multiple_stories_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_multiple_stories_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_multiple_stories_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create Multiple Stories  # noqa: E501

        Create Multiple Stories allows you to create multiple stories in a single request using the same syntax as [Create Story](https://shortcut.com/api/#create-story).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_multiple_stories_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateStories body: (required)
        :return: list[StorySlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_multiple_stories" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_multiple_stories`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/stories/bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[StorySlim]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_project(self, body, **kwargs):  # noqa: E501
        """Create Project  # noqa: E501

        Create Project is used to create a new Shortcut Project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateProject body: (required)
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_project_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_project_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_project_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create Project  # noqa: E501

        Create Project is used to create a new Shortcut Project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateProject body: (required)
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/projects', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Project',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_story(self, body, **kwargs):  # noqa: E501
        """Create Story  # noqa: E501

        Create Story is used to add a new story to your Shortcut.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_story(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateStoryParams body: Request parameters for creating a story. (required)
        :return: Story
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_story_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_story_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_story_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create Story  # noqa: E501

        Create Story is used to add a new story to your Shortcut.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_story_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateStoryParams body: Request parameters for creating a story. (required)
        :return: Story
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_story" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_story`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/stories', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Story',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_story_comment(self, body, story_public_id, **kwargs):  # noqa: E501
        """Create Story Comment  # noqa: E501

        Create Comment allows you to create a Comment on any Story.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_story_comment(body, story_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateStoryComment body: (required)
        :param int story_public_id: The ID of the Story that the Comment is in. (required)
        :return: StoryComment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_story_comment_with_http_info(body, story_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_story_comment_with_http_info(body, story_public_id, **kwargs)  # noqa: E501
            return data

    def create_story_comment_with_http_info(self, body, story_public_id, **kwargs):  # noqa: E501
        """Create Story Comment  # noqa: E501

        Create Comment allows you to create a Comment on any Story.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_story_comment_with_http_info(body, story_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateStoryComment body: (required)
        :param int story_public_id: The ID of the Story that the Comment is in. (required)
        :return: StoryComment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'story_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_story_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_story_comment`")  # noqa: E501
        # verify the required parameter 'story_public_id' is set
        if ('story_public_id' not in params or
                params['story_public_id'] is None):
            raise ValueError("Missing the required parameter `story_public_id` when calling `create_story_comment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'story_public_id' in params:
            path_params['story-public-id'] = params['story_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/stories/{story-public-id}/comments', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StoryComment',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_story_link(self, body, **kwargs):  # noqa: E501
        """Create Story Link  # noqa: E501

        Story Links (called Story Relationships in the UI) allow you create semantic relationships between two stories. The parameters read like an active voice grammatical sentence:  subject -> verb -> object.  The subject story acts on the object Story; the object story is the direct object of the sentence.  The subject story \"blocks\", \"duplicates\", or \"relates to\" the object story.  Examples: - \"story 5 blocks story 6” -- story 6 is now \"blocked\" until story 5 is moved to a Done workflow state. - \"story 2 duplicates story 1” -- Story 2 represents the same body of work as Story 1 (and should probably be archived). - \"story 7 relates to story 3”  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_story_link(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateStoryLink body: (required)
        :return: StoryLink
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_story_link_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_story_link_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_story_link_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create Story Link  # noqa: E501

        Story Links (called Story Relationships in the UI) allow you create semantic relationships between two stories. The parameters read like an active voice grammatical sentence:  subject -> verb -> object.  The subject story acts on the object Story; the object story is the direct object of the sentence.  The subject story \"blocks\", \"duplicates\", or \"relates to\" the object story.  Examples: - \"story 5 blocks story 6” -- story 6 is now \"blocked\" until story 5 is moved to a Done workflow state. - \"story 2 duplicates story 1” -- Story 2 represents the same body of work as Story 1 (and should probably be archived). - \"story 7 relates to story 3”  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_story_link_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateStoryLink body: (required)
        :return: StoryLink
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_story_link" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_story_link`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/story-links', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StoryLink',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_story_reaction(self, body, story_public_id, comment_public_id, **kwargs):  # noqa: E501
        """Create Story Reaction  # noqa: E501

        Create a reaction to a story comment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_story_reaction(body, story_public_id, comment_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateOrDeleteStoryReaction body: (required)
        :param int story_public_id: The ID of the Story that the Comment is in. (required)
        :param int comment_public_id: The ID of the Comment. (required)
        :return: list[StoryReaction]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_story_reaction_with_http_info(body, story_public_id, comment_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_story_reaction_with_http_info(body, story_public_id, comment_public_id, **kwargs)  # noqa: E501
            return data

    def create_story_reaction_with_http_info(self, body, story_public_id, comment_public_id, **kwargs):  # noqa: E501
        """Create Story Reaction  # noqa: E501

        Create a reaction to a story comment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_story_reaction_with_http_info(body, story_public_id, comment_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateOrDeleteStoryReaction body: (required)
        :param int story_public_id: The ID of the Story that the Comment is in. (required)
        :param int comment_public_id: The ID of the Comment. (required)
        :return: list[StoryReaction]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'story_public_id', 'comment_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_story_reaction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_story_reaction`")  # noqa: E501
        # verify the required parameter 'story_public_id' is set
        if ('story_public_id' not in params or
                params['story_public_id'] is None):
            raise ValueError("Missing the required parameter `story_public_id` when calling `create_story_reaction`")  # noqa: E501
        # verify the required parameter 'comment_public_id' is set
        if ('comment_public_id' not in params or
                params['comment_public_id'] is None):
            raise ValueError("Missing the required parameter `comment_public_id` when calling `create_story_reaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'story_public_id' in params:
            path_params['story-public-id'] = params['story_public_id']  # noqa: E501
        if 'comment_public_id' in params:
            path_params['comment-public-id'] = params['comment_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/stories/{story-public-id}/comments/{comment-public-id}/reactions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[StoryReaction]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_task(self, body, story_public_id, **kwargs):  # noqa: E501
        """Create Task  # noqa: E501

        Create Task is used to create a new task in a Story.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_task(body, story_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateTask body: (required)
        :param int story_public_id: The ID of the Story that the Task will be in. (required)
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_task_with_http_info(body, story_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_task_with_http_info(body, story_public_id, **kwargs)  # noqa: E501
            return data

    def create_task_with_http_info(self, body, story_public_id, **kwargs):  # noqa: E501
        """Create Task  # noqa: E501

        Create Task is used to create a new task in a Story.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_task_with_http_info(body, story_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateTask body: (required)
        :param int story_public_id: The ID of the Story that the Task will be in. (required)
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'story_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_task`")  # noqa: E501
        # verify the required parameter 'story_public_id' is set
        if ('story_public_id' not in params or
                params['story_public_id'] is None):
            raise ValueError("Missing the required parameter `story_public_id` when calling `create_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'story_public_id' in params:
            path_params['story-public-id'] = params['story_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/stories/{story-public-id}/tasks', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Task',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_category(self, category_public_id, **kwargs):  # noqa: E501
        """Delete Category  # noqa: E501

        Delete Category can be used to delete any Category.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_category(category_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int category_public_id: The unique ID of the Category. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_category_with_http_info(category_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_category_with_http_info(category_public_id, **kwargs)  # noqa: E501
            return data

    def delete_category_with_http_info(self, category_public_id, **kwargs):  # noqa: E501
        """Delete Category  # noqa: E501

        Delete Category can be used to delete any Category.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_category_with_http_info(category_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int category_public_id: The unique ID of the Category. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['category_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_category" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'category_public_id' is set
        if ('category_public_id' not in params or
                params['category_public_id'] is None):
            raise ValueError("Missing the required parameter `category_public_id` when calling `delete_category`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'category_public_id' in params:
            path_params['category-public-id'] = params['category_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/categories/{category-public-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_entity_template(self, entity_template_public_id, **kwargs):  # noqa: E501
        """Delete Entity Template  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_entity_template(entity_template_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str entity_template_public_id: The unique ID of the entity template. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_entity_template_with_http_info(entity_template_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_entity_template_with_http_info(entity_template_public_id, **kwargs)  # noqa: E501
            return data

    def delete_entity_template_with_http_info(self, entity_template_public_id, **kwargs):  # noqa: E501
        """Delete Entity Template  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_entity_template_with_http_info(entity_template_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str entity_template_public_id: The unique ID of the entity template. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entity_template_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_entity_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entity_template_public_id' is set
        if ('entity_template_public_id' not in params or
                params['entity_template_public_id'] is None):
            raise ValueError("Missing the required parameter `entity_template_public_id` when calling `delete_entity_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entity_template_public_id' in params:
            path_params['entity-template-public-id'] = params['entity_template_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/entity-templates/{entity-template-public-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_epic(self, epic_public_id, **kwargs):  # noqa: E501
        """Delete Epic  # noqa: E501

        Delete Epic can be used to delete the Epic. The only required parameter is Epic ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_epic(epic_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int epic_public_id: The unique ID of the Epic. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_epic_with_http_info(epic_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_epic_with_http_info(epic_public_id, **kwargs)  # noqa: E501
            return data

    def delete_epic_with_http_info(self, epic_public_id, **kwargs):  # noqa: E501
        """Delete Epic  # noqa: E501

        Delete Epic can be used to delete the Epic. The only required parameter is Epic ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_epic_with_http_info(epic_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int epic_public_id: The unique ID of the Epic. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['epic_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_epic" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'epic_public_id' is set
        if ('epic_public_id' not in params or
                params['epic_public_id'] is None):
            raise ValueError("Missing the required parameter `epic_public_id` when calling `delete_epic`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'epic_public_id' in params:
            path_params['epic-public-id'] = params['epic_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/epics/{epic-public-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_epic_comment(self, epic_public_id, comment_public_id, **kwargs):  # noqa: E501
        """Delete Epic Comment  # noqa: E501

        This endpoint allows you to delete a Comment from an Epic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_epic_comment(epic_public_id, comment_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int epic_public_id: The ID of the associated Epic. (required)
        :param int comment_public_id: The ID of the Comment. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_epic_comment_with_http_info(epic_public_id, comment_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_epic_comment_with_http_info(epic_public_id, comment_public_id, **kwargs)  # noqa: E501
            return data

    def delete_epic_comment_with_http_info(self, epic_public_id, comment_public_id, **kwargs):  # noqa: E501
        """Delete Epic Comment  # noqa: E501

        This endpoint allows you to delete a Comment from an Epic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_epic_comment_with_http_info(epic_public_id, comment_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int epic_public_id: The ID of the associated Epic. (required)
        :param int comment_public_id: The ID of the Comment. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['epic_public_id', 'comment_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_epic_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'epic_public_id' is set
        if ('epic_public_id' not in params or
                params['epic_public_id'] is None):
            raise ValueError("Missing the required parameter `epic_public_id` when calling `delete_epic_comment`")  # noqa: E501
        # verify the required parameter 'comment_public_id' is set
        if ('comment_public_id' not in params or
                params['comment_public_id'] is None):
            raise ValueError("Missing the required parameter `comment_public_id` when calling `delete_epic_comment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'epic_public_id' in params:
            path_params['epic-public-id'] = params['epic_public_id']  # noqa: E501
        if 'comment_public_id' in params:
            path_params['comment-public-id'] = params['comment_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/epics/{epic-public-id}/comments/{comment-public-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_file(self, file_public_id, **kwargs):  # noqa: E501
        """Delete File  # noqa: E501

        Delete File deletes a previously uploaded file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_file(file_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int file_public_id: The File’s unique ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_file_with_http_info(file_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_file_with_http_info(file_public_id, **kwargs)  # noqa: E501
            return data

    def delete_file_with_http_info(self, file_public_id, **kwargs):  # noqa: E501
        """Delete File  # noqa: E501

        Delete File deletes a previously uploaded file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_file_with_http_info(file_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int file_public_id: The File’s unique ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_public_id' is set
        if ('file_public_id' not in params or
                params['file_public_id'] is None):
            raise ValueError("Missing the required parameter `file_public_id` when calling `delete_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_public_id' in params:
            path_params['file-public-id'] = params['file_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/files/{file-public-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_iteration(self, iteration_public_id, **kwargs):  # noqa: E501
        """Delete Iteration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_iteration(iteration_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int iteration_public_id: The unique ID of the Iteration. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_iteration_with_http_info(iteration_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_iteration_with_http_info(iteration_public_id, **kwargs)  # noqa: E501
            return data

    def delete_iteration_with_http_info(self, iteration_public_id, **kwargs):  # noqa: E501
        """Delete Iteration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_iteration_with_http_info(iteration_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int iteration_public_id: The unique ID of the Iteration. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['iteration_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_iteration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'iteration_public_id' is set
        if ('iteration_public_id' not in params or
                params['iteration_public_id'] is None):
            raise ValueError("Missing the required parameter `iteration_public_id` when calling `delete_iteration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'iteration_public_id' in params:
            path_params['iteration-public-id'] = params['iteration_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/iterations/{iteration-public-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_label(self, label_public_id, **kwargs):  # noqa: E501
        """Delete Label  # noqa: E501

        Delete Label can be used to delete any Label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_label(label_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int label_public_id: The unique ID of the Label. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_label_with_http_info(label_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_label_with_http_info(label_public_id, **kwargs)  # noqa: E501
            return data

    def delete_label_with_http_info(self, label_public_id, **kwargs):  # noqa: E501
        """Delete Label  # noqa: E501

        Delete Label can be used to delete any Label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_label_with_http_info(label_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int label_public_id: The unique ID of the Label. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['label_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_label" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'label_public_id' is set
        if ('label_public_id' not in params or
                params['label_public_id'] is None):
            raise ValueError("Missing the required parameter `label_public_id` when calling `delete_label`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'label_public_id' in params:
            path_params['label-public-id'] = params['label_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/labels/{label-public-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_linked_file(self, linked_file_public_id, **kwargs):  # noqa: E501
        """Delete Linked File  # noqa: E501

        Delete Linked File can be used to delete any previously attached Linked-File.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_linked_file(linked_file_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int linked_file_public_id: The unique identifier of the linked file. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_linked_file_with_http_info(linked_file_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_linked_file_with_http_info(linked_file_public_id, **kwargs)  # noqa: E501
            return data

    def delete_linked_file_with_http_info(self, linked_file_public_id, **kwargs):  # noqa: E501
        """Delete Linked File  # noqa: E501

        Delete Linked File can be used to delete any previously attached Linked-File.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_linked_file_with_http_info(linked_file_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int linked_file_public_id: The unique identifier of the linked file. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['linked_file_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_linked_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'linked_file_public_id' is set
        if ('linked_file_public_id' not in params or
                params['linked_file_public_id'] is None):
            raise ValueError("Missing the required parameter `linked_file_public_id` when calling `delete_linked_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'linked_file_public_id' in params:
            path_params['linked-file-public-id'] = params['linked_file_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/linked-files/{linked-file-public-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_milestone(self, milestone_public_id, **kwargs):  # noqa: E501
        """Delete Milestone  # noqa: E501

        Delete Milestone can be used to delete any Milestone.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_milestone(milestone_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int milestone_public_id: The ID of the Milestone. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_milestone_with_http_info(milestone_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_milestone_with_http_info(milestone_public_id, **kwargs)  # noqa: E501
            return data

    def delete_milestone_with_http_info(self, milestone_public_id, **kwargs):  # noqa: E501
        """Delete Milestone  # noqa: E501

        Delete Milestone can be used to delete any Milestone.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_milestone_with_http_info(milestone_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int milestone_public_id: The ID of the Milestone. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['milestone_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_milestone" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'milestone_public_id' is set
        if ('milestone_public_id' not in params or
                params['milestone_public_id'] is None):
            raise ValueError("Missing the required parameter `milestone_public_id` when calling `delete_milestone`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'milestone_public_id' in params:
            path_params['milestone-public-id'] = params['milestone_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/milestones/{milestone-public-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_multiple_stories(self, body, **kwargs):  # noqa: E501
        """Delete Multiple Stories  # noqa: E501

        Delete Multiple Stories allows you to delete multiple archived stories at once.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_multiple_stories(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteStories body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_multiple_stories_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_multiple_stories_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def delete_multiple_stories_with_http_info(self, body, **kwargs):  # noqa: E501
        """Delete Multiple Stories  # noqa: E501

        Delete Multiple Stories allows you to delete multiple archived stories at once.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_multiple_stories_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteStories body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_multiple_stories" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `delete_multiple_stories`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/stories/bulk', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_project(self, project_public_id, **kwargs):  # noqa: E501
        """Delete Project  # noqa: E501

        Delete Project can be used to delete a Project. Projects can only be deleted if all associated Stories are moved or deleted. In the case that the Project cannot be deleted, you will receive a 422 response.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_project(project_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_public_id: The unique ID of the Project. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_project_with_http_info(project_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_project_with_http_info(project_public_id, **kwargs)  # noqa: E501
            return data

    def delete_project_with_http_info(self, project_public_id, **kwargs):  # noqa: E501
        """Delete Project  # noqa: E501

        Delete Project can be used to delete a Project. Projects can only be deleted if all associated Stories are moved or deleted. In the case that the Project cannot be deleted, you will receive a 422 response.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_project_with_http_info(project_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_public_id: The unique ID of the Project. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_public_id' is set
        if ('project_public_id' not in params or
                params['project_public_id'] is None):
            raise ValueError("Missing the required parameter `project_public_id` when calling `delete_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_public_id' in params:
            path_params['project-public-id'] = params['project_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/projects/{project-public-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_story(self, story_public_id, **kwargs):  # noqa: E501
        """Delete Story  # noqa: E501

        Delete Story can be used to delete any Story.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_story(story_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int story_public_id: The ID of the Story. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_story_with_http_info(story_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_story_with_http_info(story_public_id, **kwargs)  # noqa: E501
            return data

    def delete_story_with_http_info(self, story_public_id, **kwargs):  # noqa: E501
        """Delete Story  # noqa: E501

        Delete Story can be used to delete any Story.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_story_with_http_info(story_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int story_public_id: The ID of the Story. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['story_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_story" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'story_public_id' is set
        if ('story_public_id' not in params or
                params['story_public_id'] is None):
            raise ValueError("Missing the required parameter `story_public_id` when calling `delete_story`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'story_public_id' in params:
            path_params['story-public-id'] = params['story_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/stories/{story-public-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_story_comment(self, story_public_id, comment_public_id, **kwargs):  # noqa: E501
        """Delete Story Comment  # noqa: E501

        Delete a Comment from any story.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_story_comment(story_public_id, comment_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int story_public_id: The ID of the Story that the Comment is in. (required)
        :param int comment_public_id: The ID of the Comment. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_story_comment_with_http_info(story_public_id, comment_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_story_comment_with_http_info(story_public_id, comment_public_id, **kwargs)  # noqa: E501
            return data

    def delete_story_comment_with_http_info(self, story_public_id, comment_public_id, **kwargs):  # noqa: E501
        """Delete Story Comment  # noqa: E501

        Delete a Comment from any story.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_story_comment_with_http_info(story_public_id, comment_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int story_public_id: The ID of the Story that the Comment is in. (required)
        :param int comment_public_id: The ID of the Comment. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['story_public_id', 'comment_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_story_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'story_public_id' is set
        if ('story_public_id' not in params or
                params['story_public_id'] is None):
            raise ValueError("Missing the required parameter `story_public_id` when calling `delete_story_comment`")  # noqa: E501
        # verify the required parameter 'comment_public_id' is set
        if ('comment_public_id' not in params or
                params['comment_public_id'] is None):
            raise ValueError("Missing the required parameter `comment_public_id` when calling `delete_story_comment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'story_public_id' in params:
            path_params['story-public-id'] = params['story_public_id']  # noqa: E501
        if 'comment_public_id' in params:
            path_params['comment-public-id'] = params['comment_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/stories/{story-public-id}/comments/{comment-public-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_story_link(self, story_link_public_id, **kwargs):  # noqa: E501
        """Delete Story Link  # noqa: E501

        Removes the relationship between the stories for the given Story Link.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_story_link(story_link_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int story_link_public_id: The unique ID of the Story Link. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_story_link_with_http_info(story_link_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_story_link_with_http_info(story_link_public_id, **kwargs)  # noqa: E501
            return data

    def delete_story_link_with_http_info(self, story_link_public_id, **kwargs):  # noqa: E501
        """Delete Story Link  # noqa: E501

        Removes the relationship between the stories for the given Story Link.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_story_link_with_http_info(story_link_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int story_link_public_id: The unique ID of the Story Link. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['story_link_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_story_link" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'story_link_public_id' is set
        if ('story_link_public_id' not in params or
                params['story_link_public_id'] is None):
            raise ValueError("Missing the required parameter `story_link_public_id` when calling `delete_story_link`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'story_link_public_id' in params:
            path_params['story-link-public-id'] = params['story_link_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/story-links/{story-link-public-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_story_reaction(self, body, story_public_id, comment_public_id, **kwargs):  # noqa: E501
        """Delete Story Reaction  # noqa: E501

        Delete a reaction from any story comment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_story_reaction(body, story_public_id, comment_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateOrDeleteStoryReaction body: (required)
        :param int story_public_id: The ID of the Story that the Comment is in. (required)
        :param int comment_public_id: The ID of the Comment. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_story_reaction_with_http_info(body, story_public_id, comment_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_story_reaction_with_http_info(body, story_public_id, comment_public_id, **kwargs)  # noqa: E501
            return data

    def delete_story_reaction_with_http_info(self, body, story_public_id, comment_public_id, **kwargs):  # noqa: E501
        """Delete Story Reaction  # noqa: E501

        Delete a reaction from any story comment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_story_reaction_with_http_info(body, story_public_id, comment_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateOrDeleteStoryReaction body: (required)
        :param int story_public_id: The ID of the Story that the Comment is in. (required)
        :param int comment_public_id: The ID of the Comment. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'story_public_id', 'comment_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_story_reaction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `delete_story_reaction`")  # noqa: E501
        # verify the required parameter 'story_public_id' is set
        if ('story_public_id' not in params or
                params['story_public_id'] is None):
            raise ValueError("Missing the required parameter `story_public_id` when calling `delete_story_reaction`")  # noqa: E501
        # verify the required parameter 'comment_public_id' is set
        if ('comment_public_id' not in params or
                params['comment_public_id'] is None):
            raise ValueError("Missing the required parameter `comment_public_id` when calling `delete_story_reaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'story_public_id' in params:
            path_params['story-public-id'] = params['story_public_id']  # noqa: E501
        if 'comment_public_id' in params:
            path_params['comment-public-id'] = params['comment_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/stories/{story-public-id}/comments/{comment-public-id}/reactions', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_task(self, story_public_id, task_public_id, **kwargs):  # noqa: E501
        """Delete Task  # noqa: E501

        Delete Task can be used to delete any previously created Task on a Story.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_task(story_public_id, task_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int story_public_id: The unique ID of the Story this Task is associated with. (required)
        :param int task_public_id: The unique ID of the Task. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_task_with_http_info(story_public_id, task_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_task_with_http_info(story_public_id, task_public_id, **kwargs)  # noqa: E501
            return data

    def delete_task_with_http_info(self, story_public_id, task_public_id, **kwargs):  # noqa: E501
        """Delete Task  # noqa: E501

        Delete Task can be used to delete any previously created Task on a Story.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_task_with_http_info(story_public_id, task_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int story_public_id: The unique ID of the Story this Task is associated with. (required)
        :param int task_public_id: The unique ID of the Task. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['story_public_id', 'task_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'story_public_id' is set
        if ('story_public_id' not in params or
                params['story_public_id'] is None):
            raise ValueError("Missing the required parameter `story_public_id` when calling `delete_task`")  # noqa: E501
        # verify the required parameter 'task_public_id' is set
        if ('task_public_id' not in params or
                params['task_public_id'] is None):
            raise ValueError("Missing the required parameter `task_public_id` when calling `delete_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'story_public_id' in params:
            path_params['story-public-id'] = params['story_public_id']  # noqa: E501
        if 'task_public_id' in params:
            path_params['task-public-id'] = params['task_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/stories/{story-public-id}/tasks/{task-public-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def disable_groups(self, **kwargs):  # noqa: E501
        """Disable Groups  # noqa: E501

        Disables Groups for the current workspace2  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_groups(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.disable_groups_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.disable_groups_with_http_info(**kwargs)  # noqa: E501
            return data

    def disable_groups_with_http_info(self, **kwargs):  # noqa: E501
        """Disable Groups  # noqa: E501

        Disables Groups for the current workspace2  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_groups_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable_groups" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/groups/disable', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def disable_iterations(self, **kwargs):  # noqa: E501
        """Disable Iterations  # noqa: E501

        Disables Iterations for the current workspace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_iterations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.disable_iterations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.disable_iterations_with_http_info(**kwargs)  # noqa: E501
            return data

    def disable_iterations_with_http_info(self, **kwargs):  # noqa: E501
        """Disable Iterations  # noqa: E501

        Disables Iterations for the current workspace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_iterations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable_iterations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/iterations/disable', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def disable_story_templates(self, **kwargs):  # noqa: E501
        """Disable Story Templates  # noqa: E501

        Disables the Story Template feature for the Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_story_templates(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.disable_story_templates_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.disable_story_templates_with_http_info(**kwargs)  # noqa: E501
            return data

    def disable_story_templates_with_http_info(self, **kwargs):  # noqa: E501
        """Disable Story Templates  # noqa: E501

        Disables the Story Template feature for the Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_story_templates_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable_story_templates" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/entity-templates/disable', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_groups(self, **kwargs):  # noqa: E501
        """Enable Groups  # noqa: E501

        Enables Groups for the current workspace2  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_groups(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_groups_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.enable_groups_with_http_info(**kwargs)  # noqa: E501
            return data

    def enable_groups_with_http_info(self, **kwargs):  # noqa: E501
        """Enable Groups  # noqa: E501

        Enables Groups for the current workspace2  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_groups_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_groups" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/groups/enable', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_iterations(self, **kwargs):  # noqa: E501
        """Enable Iterations  # noqa: E501

        Enables Iterations for the current workspace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_iterations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_iterations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.enable_iterations_with_http_info(**kwargs)  # noqa: E501
            return data

    def enable_iterations_with_http_info(self, **kwargs):  # noqa: E501
        """Enable Iterations  # noqa: E501

        Enables Iterations for the current workspace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_iterations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_iterations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/iterations/enable', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_story_templates(self, **kwargs):  # noqa: E501
        """Enable Story Templates  # noqa: E501

        Enables the Story Template feature for the Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_story_templates(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_story_templates_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.enable_story_templates_with_http_info(**kwargs)  # noqa: E501
            return data

    def enable_story_templates_with_http_info(self, **kwargs):  # noqa: E501
        """Enable Story Templates  # noqa: E501

        Enables the Story Template feature for the Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_story_templates_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_story_templates" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/entity-templates/enable', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_category(self, category_public_id, **kwargs):  # noqa: E501
        """Get Category  # noqa: E501

        Get Category returns information about the selected Category.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_category(category_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int category_public_id: The unique ID of the Category. (required)
        :return: Category
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_category_with_http_info(category_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_category_with_http_info(category_public_id, **kwargs)  # noqa: E501
            return data

    def get_category_with_http_info(self, category_public_id, **kwargs):  # noqa: E501
        """Get Category  # noqa: E501

        Get Category returns information about the selected Category.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_category_with_http_info(category_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int category_public_id: The unique ID of the Category. (required)
        :return: Category
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['category_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_category" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'category_public_id' is set
        if ('category_public_id' not in params or
                params['category_public_id'] is None):
            raise ValueError("Missing the required parameter `category_public_id` when calling `get_category`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'category_public_id' in params:
            path_params['category-public-id'] = params['category_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/categories/{category-public-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Category',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_current_member_info(self, **kwargs):  # noqa: E501
        """Get Current Member Info  # noqa: E501

        Returns information about the authenticated member.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_current_member_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: MemberInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_current_member_info_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_current_member_info_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_current_member_info_with_http_info(self, **kwargs):  # noqa: E501
        """Get Current Member Info  # noqa: E501

        Returns information about the authenticated member.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_current_member_info_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: MemberInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_current_member_info" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/member', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MemberInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_entity_template(self, entity_template_public_id, **kwargs):  # noqa: E501
        """Get Entity Template  # noqa: E501

        Get Entity Template returns information about a given entity template.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_entity_template(entity_template_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str entity_template_public_id: The unique ID of the entity template. (required)
        :return: EntityTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_entity_template_with_http_info(entity_template_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_entity_template_with_http_info(entity_template_public_id, **kwargs)  # noqa: E501
            return data

    def get_entity_template_with_http_info(self, entity_template_public_id, **kwargs):  # noqa: E501
        """Get Entity Template  # noqa: E501

        Get Entity Template returns information about a given entity template.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_entity_template_with_http_info(entity_template_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str entity_template_public_id: The unique ID of the entity template. (required)
        :return: EntityTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entity_template_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_entity_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entity_template_public_id' is set
        if ('entity_template_public_id' not in params or
                params['entity_template_public_id'] is None):
            raise ValueError("Missing the required parameter `entity_template_public_id` when calling `get_entity_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entity_template_public_id' in params:
            path_params['entity-template-public-id'] = params['entity_template_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/entity-templates/{entity-template-public-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EntityTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_epic(self, epic_public_id, **kwargs):  # noqa: E501
        """Get Epic  # noqa: E501

        Get Epic returns information about the selected Epic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_epic(epic_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int epic_public_id: The unique ID of the Epic. (required)
        :return: Epic
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_epic_with_http_info(epic_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_epic_with_http_info(epic_public_id, **kwargs)  # noqa: E501
            return data

    def get_epic_with_http_info(self, epic_public_id, **kwargs):  # noqa: E501
        """Get Epic  # noqa: E501

        Get Epic returns information about the selected Epic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_epic_with_http_info(epic_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int epic_public_id: The unique ID of the Epic. (required)
        :return: Epic
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['epic_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_epic" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'epic_public_id' is set
        if ('epic_public_id' not in params or
                params['epic_public_id'] is None):
            raise ValueError("Missing the required parameter `epic_public_id` when calling `get_epic`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'epic_public_id' in params:
            path_params['epic-public-id'] = params['epic_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/epics/{epic-public-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Epic',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_epic_comment(self, epic_public_id, comment_public_id, **kwargs):  # noqa: E501
        """Get Epic Comment  # noqa: E501

        This endpoint returns information about the selected Epic Comment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_epic_comment(epic_public_id, comment_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int epic_public_id: The ID of the associated Epic. (required)
        :param int comment_public_id: The ID of the Comment. (required)
        :return: ThreadedComment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_epic_comment_with_http_info(epic_public_id, comment_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_epic_comment_with_http_info(epic_public_id, comment_public_id, **kwargs)  # noqa: E501
            return data

    def get_epic_comment_with_http_info(self, epic_public_id, comment_public_id, **kwargs):  # noqa: E501
        """Get Epic Comment  # noqa: E501

        This endpoint returns information about the selected Epic Comment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_epic_comment_with_http_info(epic_public_id, comment_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int epic_public_id: The ID of the associated Epic. (required)
        :param int comment_public_id: The ID of the Comment. (required)
        :return: ThreadedComment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['epic_public_id', 'comment_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_epic_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'epic_public_id' is set
        if ('epic_public_id' not in params or
                params['epic_public_id'] is None):
            raise ValueError("Missing the required parameter `epic_public_id` when calling `get_epic_comment`")  # noqa: E501
        # verify the required parameter 'comment_public_id' is set
        if ('comment_public_id' not in params or
                params['comment_public_id'] is None):
            raise ValueError("Missing the required parameter `comment_public_id` when calling `get_epic_comment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'epic_public_id' in params:
            path_params['epic-public-id'] = params['epic_public_id']  # noqa: E501
        if 'comment_public_id' in params:
            path_params['comment-public-id'] = params['comment_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/epics/{epic-public-id}/comments/{comment-public-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ThreadedComment',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_epic_workflow(self, **kwargs):  # noqa: E501
        """Get Epic Workflow  # noqa: E501

        Returns the Epic Workflow for the Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_epic_workflow(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: EpicWorkflow
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_epic_workflow_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_epic_workflow_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_epic_workflow_with_http_info(self, **kwargs):  # noqa: E501
        """Get Epic Workflow  # noqa: E501

        Returns the Epic Workflow for the Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_epic_workflow_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: EpicWorkflow
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_epic_workflow" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/epic-workflow', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EpicWorkflow',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_external_link_stories(self, body, **kwargs):  # noqa: E501
        """Get External Link Stories  # noqa: E501

        Get Stories which have a given External Link associated with them.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_external_link_stories(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GetExternalLinkStoriesParams body: (required)
        :return: list[StorySlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_external_link_stories_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.get_external_link_stories_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def get_external_link_stories_with_http_info(self, body, **kwargs):  # noqa: E501
        """Get External Link Stories  # noqa: E501

        Get Stories which have a given External Link associated with them.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_external_link_stories_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GetExternalLinkStoriesParams body: (required)
        :return: list[StorySlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_external_link_stories" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `get_external_link_stories`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/external-link/stories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[StorySlim]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_file(self, file_public_id, **kwargs):  # noqa: E501
        """Get File  # noqa: E501

        Get File returns information about the selected UploadedFile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file(file_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int file_public_id: The File’s unique ID. (required)
        :return: UploadedFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_file_with_http_info(file_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_file_with_http_info(file_public_id, **kwargs)  # noqa: E501
            return data

    def get_file_with_http_info(self, file_public_id, **kwargs):  # noqa: E501
        """Get File  # noqa: E501

        Get File returns information about the selected UploadedFile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_with_http_info(file_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int file_public_id: The File’s unique ID. (required)
        :return: UploadedFile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_public_id' is set
        if ('file_public_id' not in params or
                params['file_public_id'] is None):
            raise ValueError("Missing the required parameter `file_public_id` when calling `get_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_public_id' in params:
            path_params['file-public-id'] = params['file_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/files/{file-public-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UploadedFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_group(self, group_public_id, **kwargs):  # noqa: E501
        """Get Group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_group(group_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_public_id: The unique ID of the Group. (required)
        :return: Group
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_group_with_http_info(group_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_group_with_http_info(group_public_id, **kwargs)  # noqa: E501
            return data

    def get_group_with_http_info(self, group_public_id, **kwargs):  # noqa: E501
        """Get Group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_group_with_http_info(group_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_public_id: The unique ID of the Group. (required)
        :return: Group
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_public_id' is set
        if ('group_public_id' not in params or
                params['group_public_id'] is None):
            raise ValueError("Missing the required parameter `group_public_id` when calling `get_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_public_id' in params:
            path_params['group-public-id'] = params['group_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/groups/{group-public-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Group',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_iteration(self, iteration_public_id, **kwargs):  # noqa: E501
        """Get Iteration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_iteration(iteration_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int iteration_public_id: The unique ID of the Iteration. (required)
        :return: Iteration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_iteration_with_http_info(iteration_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_iteration_with_http_info(iteration_public_id, **kwargs)  # noqa: E501
            return data

    def get_iteration_with_http_info(self, iteration_public_id, **kwargs):  # noqa: E501
        """Get Iteration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_iteration_with_http_info(iteration_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int iteration_public_id: The unique ID of the Iteration. (required)
        :return: Iteration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['iteration_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_iteration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'iteration_public_id' is set
        if ('iteration_public_id' not in params or
                params['iteration_public_id'] is None):
            raise ValueError("Missing the required parameter `iteration_public_id` when calling `get_iteration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'iteration_public_id' in params:
            path_params['iteration-public-id'] = params['iteration_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/iterations/{iteration-public-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Iteration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_label(self, label_public_id, **kwargs):  # noqa: E501
        """Get Label  # noqa: E501

        Get Label returns information about the selected Label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_label(label_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int label_public_id: The unique ID of the Label. (required)
        :return: Label
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_label_with_http_info(label_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_label_with_http_info(label_public_id, **kwargs)  # noqa: E501
            return data

    def get_label_with_http_info(self, label_public_id, **kwargs):  # noqa: E501
        """Get Label  # noqa: E501

        Get Label returns information about the selected Label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_label_with_http_info(label_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int label_public_id: The unique ID of the Label. (required)
        :return: Label
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['label_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_label" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'label_public_id' is set
        if ('label_public_id' not in params or
                params['label_public_id'] is None):
            raise ValueError("Missing the required parameter `label_public_id` when calling `get_label`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'label_public_id' in params:
            path_params['label-public-id'] = params['label_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/labels/{label-public-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Label',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_linked_file(self, linked_file_public_id, **kwargs):  # noqa: E501
        """Get Linked File  # noqa: E501

        Get File returns information about the selected Linked File.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_linked_file(linked_file_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int linked_file_public_id: The unique identifier of the linked file. (required)
        :return: LinkedFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_linked_file_with_http_info(linked_file_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_linked_file_with_http_info(linked_file_public_id, **kwargs)  # noqa: E501
            return data

    def get_linked_file_with_http_info(self, linked_file_public_id, **kwargs):  # noqa: E501
        """Get Linked File  # noqa: E501

        Get File returns information about the selected Linked File.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_linked_file_with_http_info(linked_file_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int linked_file_public_id: The unique identifier of the linked file. (required)
        :return: LinkedFile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['linked_file_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_linked_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'linked_file_public_id' is set
        if ('linked_file_public_id' not in params or
                params['linked_file_public_id'] is None):
            raise ValueError("Missing the required parameter `linked_file_public_id` when calling `get_linked_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'linked_file_public_id' in params:
            path_params['linked-file-public-id'] = params['linked_file_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/linked-files/{linked-file-public-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LinkedFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_member(self, body, member_public_id, **kwargs):  # noqa: E501
        """Get Member  # noqa: E501

        Returns information about a Member.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_member(body, member_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GetMember body: (required)
        :param str member_public_id: The Member's unique ID. (required)
        :return: Member
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_member_with_http_info(body, member_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_member_with_http_info(body, member_public_id, **kwargs)  # noqa: E501
            return data

    def get_member_with_http_info(self, body, member_public_id, **kwargs):  # noqa: E501
        """Get Member  # noqa: E501

        Returns information about a Member.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_member_with_http_info(body, member_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GetMember body: (required)
        :param str member_public_id: The Member's unique ID. (required)
        :return: Member
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'member_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_member" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `get_member`")  # noqa: E501
        # verify the required parameter 'member_public_id' is set
        if ('member_public_id' not in params or
                params['member_public_id'] is None):
            raise ValueError("Missing the required parameter `member_public_id` when calling `get_member`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'member_public_id' in params:
            path_params['member-public-id'] = params['member_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/members/{member-public-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Member',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_milestone(self, milestone_public_id, **kwargs):  # noqa: E501
        """Get Milestone  # noqa: E501

        Get Milestone returns information about a chosen Milestone.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_milestone(milestone_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int milestone_public_id: The ID of the Milestone. (required)
        :return: Milestone
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_milestone_with_http_info(milestone_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_milestone_with_http_info(milestone_public_id, **kwargs)  # noqa: E501
            return data

    def get_milestone_with_http_info(self, milestone_public_id, **kwargs):  # noqa: E501
        """Get Milestone  # noqa: E501

        Get Milestone returns information about a chosen Milestone.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_milestone_with_http_info(milestone_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int milestone_public_id: The ID of the Milestone. (required)
        :return: Milestone
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['milestone_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_milestone" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'milestone_public_id' is set
        if ('milestone_public_id' not in params or
                params['milestone_public_id'] is None):
            raise ValueError("Missing the required parameter `milestone_public_id` when calling `get_milestone`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'milestone_public_id' in params:
            path_params['milestone-public-id'] = params['milestone_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/milestones/{milestone-public-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Milestone',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_project(self, project_public_id, **kwargs):  # noqa: E501
        """Get Project  # noqa: E501

        Get Project returns information about the selected Project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project(project_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_public_id: The unique ID of the Project. (required)
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_project_with_http_info(project_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_project_with_http_info(project_public_id, **kwargs)  # noqa: E501
            return data

    def get_project_with_http_info(self, project_public_id, **kwargs):  # noqa: E501
        """Get Project  # noqa: E501

        Get Project returns information about the selected Project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_with_http_info(project_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_public_id: The unique ID of the Project. (required)
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_public_id' is set
        if ('project_public_id' not in params or
                params['project_public_id'] is None):
            raise ValueError("Missing the required parameter `project_public_id` when calling `get_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_public_id' in params:
            path_params['project-public-id'] = params['project_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/projects/{project-public-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Project',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repository(self, repo_public_id, **kwargs):  # noqa: E501
        """Get Repository  # noqa: E501

        Get Repository returns information about the selected Repository.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repository(repo_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int repo_public_id: The unique ID of the Repository. (required)
        :return: Repository
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_repository_with_http_info(repo_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_repository_with_http_info(repo_public_id, **kwargs)  # noqa: E501
            return data

    def get_repository_with_http_info(self, repo_public_id, **kwargs):  # noqa: E501
        """Get Repository  # noqa: E501

        Get Repository returns information about the selected Repository.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repository_with_http_info(repo_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int repo_public_id: The unique ID of the Repository. (required)
        :return: Repository
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repository" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_public_id' is set
        if ('repo_public_id' not in params or
                params['repo_public_id'] is None):
            raise ValueError("Missing the required parameter `repo_public_id` when calling `get_repository`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_public_id' in params:
            path_params['repo-public-id'] = params['repo_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/repositories/{repo-public-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Repository',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_story(self, story_public_id, **kwargs):  # noqa: E501
        """Get Story  # noqa: E501

        Get Story returns information about a chosen Story.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_story(story_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int story_public_id: The ID of the Story. (required)
        :return: Story
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_story_with_http_info(story_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_story_with_http_info(story_public_id, **kwargs)  # noqa: E501
            return data

    def get_story_with_http_info(self, story_public_id, **kwargs):  # noqa: E501
        """Get Story  # noqa: E501

        Get Story returns information about a chosen Story.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_story_with_http_info(story_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int story_public_id: The ID of the Story. (required)
        :return: Story
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['story_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_story" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'story_public_id' is set
        if ('story_public_id' not in params or
                params['story_public_id'] is None):
            raise ValueError("Missing the required parameter `story_public_id` when calling `get_story`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'story_public_id' in params:
            path_params['story-public-id'] = params['story_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/stories/{story-public-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Story',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_story_comment(self, story_public_id, comment_public_id, **kwargs):  # noqa: E501
        """Get Story Comment  # noqa: E501

        Get Comment is used to get Comment information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_story_comment(story_public_id, comment_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int story_public_id: The ID of the Story that the Comment is in. (required)
        :param int comment_public_id: The ID of the Comment. (required)
        :return: StoryComment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_story_comment_with_http_info(story_public_id, comment_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_story_comment_with_http_info(story_public_id, comment_public_id, **kwargs)  # noqa: E501
            return data

    def get_story_comment_with_http_info(self, story_public_id, comment_public_id, **kwargs):  # noqa: E501
        """Get Story Comment  # noqa: E501

        Get Comment is used to get Comment information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_story_comment_with_http_info(story_public_id, comment_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int story_public_id: The ID of the Story that the Comment is in. (required)
        :param int comment_public_id: The ID of the Comment. (required)
        :return: StoryComment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['story_public_id', 'comment_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_story_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'story_public_id' is set
        if ('story_public_id' not in params or
                params['story_public_id'] is None):
            raise ValueError("Missing the required parameter `story_public_id` when calling `get_story_comment`")  # noqa: E501
        # verify the required parameter 'comment_public_id' is set
        if ('comment_public_id' not in params or
                params['comment_public_id'] is None):
            raise ValueError("Missing the required parameter `comment_public_id` when calling `get_story_comment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'story_public_id' in params:
            path_params['story-public-id'] = params['story_public_id']  # noqa: E501
        if 'comment_public_id' in params:
            path_params['comment-public-id'] = params['comment_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/stories/{story-public-id}/comments/{comment-public-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StoryComment',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_story_link(self, story_link_public_id, **kwargs):  # noqa: E501
        """Get Story Link  # noqa: E501

        Returns the stories and their relationship for the given Story Link.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_story_link(story_link_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int story_link_public_id: The unique ID of the Story Link. (required)
        :return: StoryLink
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_story_link_with_http_info(story_link_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_story_link_with_http_info(story_link_public_id, **kwargs)  # noqa: E501
            return data

    def get_story_link_with_http_info(self, story_link_public_id, **kwargs):  # noqa: E501
        """Get Story Link  # noqa: E501

        Returns the stories and their relationship for the given Story Link.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_story_link_with_http_info(story_link_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int story_link_public_id: The unique ID of the Story Link. (required)
        :return: StoryLink
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['story_link_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_story_link" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'story_link_public_id' is set
        if ('story_link_public_id' not in params or
                params['story_link_public_id'] is None):
            raise ValueError("Missing the required parameter `story_link_public_id` when calling `get_story_link`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'story_link_public_id' in params:
            path_params['story-link-public-id'] = params['story_link_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/story-links/{story-link-public-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StoryLink',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_task(self, story_public_id, task_public_id, **kwargs):  # noqa: E501
        """Get Task  # noqa: E501

        Returns information about a chosen Task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task(story_public_id, task_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int story_public_id: The unique ID of the Story this Task is associated with. (required)
        :param int task_public_id: The unique ID of the Task. (required)
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_task_with_http_info(story_public_id, task_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_task_with_http_info(story_public_id, task_public_id, **kwargs)  # noqa: E501
            return data

    def get_task_with_http_info(self, story_public_id, task_public_id, **kwargs):  # noqa: E501
        """Get Task  # noqa: E501

        Returns information about a chosen Task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_with_http_info(story_public_id, task_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int story_public_id: The unique ID of the Story this Task is associated with. (required)
        :param int task_public_id: The unique ID of the Task. (required)
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['story_public_id', 'task_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'story_public_id' is set
        if ('story_public_id' not in params or
                params['story_public_id'] is None):
            raise ValueError("Missing the required parameter `story_public_id` when calling `get_task`")  # noqa: E501
        # verify the required parameter 'task_public_id' is set
        if ('task_public_id' not in params or
                params['task_public_id'] is None):
            raise ValueError("Missing the required parameter `task_public_id` when calling `get_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'story_public_id' in params:
            path_params['story-public-id'] = params['story_public_id']  # noqa: E501
        if 'task_public_id' in params:
            path_params['task-public-id'] = params['task_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/stories/{story-public-id}/tasks/{task-public-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Task',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_workflow(self, workflow_public_id, **kwargs):  # noqa: E501
        """Get Workflow  # noqa: E501

        Get Workflow returns information about a chosen Workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workflow(workflow_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int workflow_public_id: The ID of the Workflow. (required)
        :return: Workflow
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_workflow_with_http_info(workflow_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_workflow_with_http_info(workflow_public_id, **kwargs)  # noqa: E501
            return data

    def get_workflow_with_http_info(self, workflow_public_id, **kwargs):  # noqa: E501
        """Get Workflow  # noqa: E501

        Get Workflow returns information about a chosen Workflow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workflow_with_http_info(workflow_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int workflow_public_id: The ID of the Workflow. (required)
        :return: Workflow
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['workflow_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workflow" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'workflow_public_id' is set
        if ('workflow_public_id' not in params or
                params['workflow_public_id'] is None):
            raise ValueError("Missing the required parameter `workflow_public_id` when calling `get_workflow`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workflow_public_id' in params:
            path_params['workflow-public-id'] = params['workflow_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/workflows/{workflow-public-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Workflow',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_categories(self, **kwargs):  # noqa: E501
        """List Categories  # noqa: E501

        List Categories returns a list of all Categories and their attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_categories(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Category]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_categories_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_categories_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_categories_with_http_info(self, **kwargs):  # noqa: E501
        """List Categories  # noqa: E501

        List Categories returns a list of all Categories and their attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_categories_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Category]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_categories" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/categories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Category]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_category_milestones(self, category_public_id, **kwargs):  # noqa: E501
        """List Category Milestones  # noqa: E501

        List Category Milestones returns a list of all Milestones with the Category.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_category_milestones(category_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int category_public_id: The unique ID of the Category. (required)
        :return: list[Milestone]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_category_milestones_with_http_info(category_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_category_milestones_with_http_info(category_public_id, **kwargs)  # noqa: E501
            return data

    def list_category_milestones_with_http_info(self, category_public_id, **kwargs):  # noqa: E501
        """List Category Milestones  # noqa: E501

        List Category Milestones returns a list of all Milestones with the Category.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_category_milestones_with_http_info(category_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int category_public_id: The unique ID of the Category. (required)
        :return: list[Milestone]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['category_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_category_milestones" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'category_public_id' is set
        if ('category_public_id' not in params or
                params['category_public_id'] is None):
            raise ValueError("Missing the required parameter `category_public_id` when calling `list_category_milestones`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'category_public_id' in params:
            path_params['category-public-id'] = params['category_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/categories/{category-public-id}/milestones', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Milestone]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_entity_templates(self, **kwargs):  # noqa: E501
        """List Entity Templates  # noqa: E501

        List all the entity templates for the Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_entity_templates(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[EntityTemplate]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_entity_templates_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_entity_templates_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_entity_templates_with_http_info(self, **kwargs):  # noqa: E501
        """List Entity Templates  # noqa: E501

        List all the entity templates for the Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_entity_templates_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[EntityTemplate]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_entity_templates" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/entity-templates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntityTemplate]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_epic_comments(self, epic_public_id, **kwargs):  # noqa: E501
        """List Epic Comments  # noqa: E501

        Get a list of all Comments on an Epic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_epic_comments(epic_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int epic_public_id: The unique ID of the Epic. (required)
        :return: list[ThreadedComment]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_epic_comments_with_http_info(epic_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_epic_comments_with_http_info(epic_public_id, **kwargs)  # noqa: E501
            return data

    def list_epic_comments_with_http_info(self, epic_public_id, **kwargs):  # noqa: E501
        """List Epic Comments  # noqa: E501

        Get a list of all Comments on an Epic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_epic_comments_with_http_info(epic_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int epic_public_id: The unique ID of the Epic. (required)
        :return: list[ThreadedComment]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['epic_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_epic_comments" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'epic_public_id' is set
        if ('epic_public_id' not in params or
                params['epic_public_id'] is None):
            raise ValueError("Missing the required parameter `epic_public_id` when calling `list_epic_comments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'epic_public_id' in params:
            path_params['epic-public-id'] = params['epic_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/epics/{epic-public-id}/comments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ThreadedComment]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_epic_stories(self, body, epic_public_id, **kwargs):  # noqa: E501
        """List Epic Stories  # noqa: E501

        Get a list of all Stories in an Epic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_epic_stories(body, epic_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GetEpicStories body: (required)
        :param int epic_public_id: The unique ID of the Epic. (required)
        :return: list[StorySlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_epic_stories_with_http_info(body, epic_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_epic_stories_with_http_info(body, epic_public_id, **kwargs)  # noqa: E501
            return data

    def list_epic_stories_with_http_info(self, body, epic_public_id, **kwargs):  # noqa: E501
        """List Epic Stories  # noqa: E501

        Get a list of all Stories in an Epic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_epic_stories_with_http_info(body, epic_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GetEpicStories body: (required)
        :param int epic_public_id: The unique ID of the Epic. (required)
        :return: list[StorySlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'epic_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_epic_stories" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `list_epic_stories`")  # noqa: E501
        # verify the required parameter 'epic_public_id' is set
        if ('epic_public_id' not in params or
                params['epic_public_id'] is None):
            raise ValueError("Missing the required parameter `epic_public_id` when calling `list_epic_stories`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'epic_public_id' in params:
            path_params['epic-public-id'] = params['epic_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/epics/{epic-public-id}/stories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[StorySlim]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_epics(self, body, **kwargs):  # noqa: E501
        """List Epics  # noqa: E501

        List Epics returns a list of all Epics and their attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_epics(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ListEpics body: (required)
        :return: list[EpicSlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_epics_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.list_epics_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def list_epics_with_http_info(self, body, **kwargs):  # noqa: E501
        """List Epics  # noqa: E501

        List Epics returns a list of all Epics and their attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_epics_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ListEpics body: (required)
        :return: list[EpicSlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_epics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `list_epics`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/epics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EpicSlim]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_files(self, **kwargs):  # noqa: E501
        """List Files  # noqa: E501

        List Files returns a list of all UploadedFiles in the workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_files(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[UploadedFile]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_files_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_files_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_files_with_http_info(self, **kwargs):  # noqa: E501
        """List Files  # noqa: E501

        List Files returns a list of all UploadedFiles in the workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_files_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[UploadedFile]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_files" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/files', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[UploadedFile]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_group_stories(self, body, group_public_id, **kwargs):  # noqa: E501
        """List Group Stories  # noqa: E501

        List the Stories assigned to the Group. (By default, limited to 1,000).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_group_stories(body, group_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ListGroupStories body: (required)
        :param str group_public_id: The unique ID of the Group. (required)
        :return: list[StorySlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_group_stories_with_http_info(body, group_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_group_stories_with_http_info(body, group_public_id, **kwargs)  # noqa: E501
            return data

    def list_group_stories_with_http_info(self, body, group_public_id, **kwargs):  # noqa: E501
        """List Group Stories  # noqa: E501

        List the Stories assigned to the Group. (By default, limited to 1,000).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_group_stories_with_http_info(body, group_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ListGroupStories body: (required)
        :param str group_public_id: The unique ID of the Group. (required)
        :return: list[StorySlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'group_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_group_stories" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `list_group_stories`")  # noqa: E501
        # verify the required parameter 'group_public_id' is set
        if ('group_public_id' not in params or
                params['group_public_id'] is None):
            raise ValueError("Missing the required parameter `group_public_id` when calling `list_group_stories`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_public_id' in params:
            path_params['group-public-id'] = params['group_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/groups/{group-public-id}/stories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[StorySlim]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_groups(self, **kwargs):  # noqa: E501
        """List Groups  # noqa: E501

        A group in our API maps to a \"Team\" within the Shortcut Product. A Team is a collection of Users that can be associated to Stories, Epics, and Iterations within Shortcut.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_groups(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Group]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_groups_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_groups_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_groups_with_http_info(self, **kwargs):  # noqa: E501
        """List Groups  # noqa: E501

        A group in our API maps to a \"Team\" within the Shortcut Product. A Team is a collection of Users that can be associated to Stories, Epics, and Iterations within Shortcut.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_groups_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Group]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_groups" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Group]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_iteration_stories(self, body, iteration_public_id, **kwargs):  # noqa: E501
        """List Iteration Stories  # noqa: E501

        Get a list of all Stories in an Iteration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_iteration_stories(body, iteration_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GetIterationStories body: (required)
        :param int iteration_public_id: The unique ID of the Iteration. (required)
        :return: list[StorySlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_iteration_stories_with_http_info(body, iteration_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_iteration_stories_with_http_info(body, iteration_public_id, **kwargs)  # noqa: E501
            return data

    def list_iteration_stories_with_http_info(self, body, iteration_public_id, **kwargs):  # noqa: E501
        """List Iteration Stories  # noqa: E501

        Get a list of all Stories in an Iteration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_iteration_stories_with_http_info(body, iteration_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GetIterationStories body: (required)
        :param int iteration_public_id: The unique ID of the Iteration. (required)
        :return: list[StorySlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'iteration_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_iteration_stories" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `list_iteration_stories`")  # noqa: E501
        # verify the required parameter 'iteration_public_id' is set
        if ('iteration_public_id' not in params or
                params['iteration_public_id'] is None):
            raise ValueError("Missing the required parameter `iteration_public_id` when calling `list_iteration_stories`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'iteration_public_id' in params:
            path_params['iteration-public-id'] = params['iteration_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/iterations/{iteration-public-id}/stories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[StorySlim]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_iterations(self, **kwargs):  # noqa: E501
        """List Iterations  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_iterations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[IterationSlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_iterations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_iterations_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_iterations_with_http_info(self, **kwargs):  # noqa: E501
        """List Iterations  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_iterations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[IterationSlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_iterations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/iterations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IterationSlim]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_label_epics(self, label_public_id, **kwargs):  # noqa: E501
        """List Label Epics  # noqa: E501

        List all of the Epics with the Label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_label_epics(label_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int label_public_id: The unique ID of the Label. (required)
        :return: list[EpicSlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_label_epics_with_http_info(label_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_label_epics_with_http_info(label_public_id, **kwargs)  # noqa: E501
            return data

    def list_label_epics_with_http_info(self, label_public_id, **kwargs):  # noqa: E501
        """List Label Epics  # noqa: E501

        List all of the Epics with the Label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_label_epics_with_http_info(label_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int label_public_id: The unique ID of the Label. (required)
        :return: list[EpicSlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['label_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_label_epics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'label_public_id' is set
        if ('label_public_id' not in params or
                params['label_public_id'] is None):
            raise ValueError("Missing the required parameter `label_public_id` when calling `list_label_epics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'label_public_id' in params:
            path_params['label-public-id'] = params['label_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/labels/{label-public-id}/epics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EpicSlim]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_label_stories(self, body, label_public_id, **kwargs):  # noqa: E501
        """List Label Stories  # noqa: E501

        List all of the Stories with the Label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_label_stories(body, label_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GetLabelStories body: (required)
        :param int label_public_id: The unique ID of the Label. (required)
        :return: list[StorySlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_label_stories_with_http_info(body, label_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_label_stories_with_http_info(body, label_public_id, **kwargs)  # noqa: E501
            return data

    def list_label_stories_with_http_info(self, body, label_public_id, **kwargs):  # noqa: E501
        """List Label Stories  # noqa: E501

        List all of the Stories with the Label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_label_stories_with_http_info(body, label_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GetLabelStories body: (required)
        :param int label_public_id: The unique ID of the Label. (required)
        :return: list[StorySlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'label_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_label_stories" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `list_label_stories`")  # noqa: E501
        # verify the required parameter 'label_public_id' is set
        if ('label_public_id' not in params or
                params['label_public_id'] is None):
            raise ValueError("Missing the required parameter `label_public_id` when calling `list_label_stories`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'label_public_id' in params:
            path_params['label-public-id'] = params['label_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/labels/{label-public-id}/stories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[StorySlim]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_labels(self, body, **kwargs):  # noqa: E501
        """List Labels  # noqa: E501

        List Labels returns a list of all Labels and their attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_labels(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ListLabels body: (required)
        :return: list[Label]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_labels_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.list_labels_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def list_labels_with_http_info(self, body, **kwargs):  # noqa: E501
        """List Labels  # noqa: E501

        List Labels returns a list of all Labels and their attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_labels_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ListLabels body: (required)
        :return: list[Label]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_labels" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `list_labels`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/labels', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Label]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_linked_files(self, **kwargs):  # noqa: E501
        """List Linked Files  # noqa: E501

        List Linked Files returns a list of all Linked-Files and their attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_linked_files(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[LinkedFile]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_linked_files_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_linked_files_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_linked_files_with_http_info(self, **kwargs):  # noqa: E501
        """List Linked Files  # noqa: E501

        List Linked Files returns a list of all Linked-Files and their attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_linked_files_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[LinkedFile]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_linked_files" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/linked-files', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[LinkedFile]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_members(self, body, **kwargs):  # noqa: E501
        """List Members  # noqa: E501

        Returns information about members of the Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_members(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ListMembers body: (required)
        :return: list[Member]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_members_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.list_members_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def list_members_with_http_info(self, body, **kwargs):  # noqa: E501
        """List Members  # noqa: E501

        Returns information about members of the Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_members_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ListMembers body: (required)
        :return: list[Member]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_members" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `list_members`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Member]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_milestone_epics(self, milestone_public_id, **kwargs):  # noqa: E501
        """List Milestone Epics  # noqa: E501

        List all of the Epics within the Milestone.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_milestone_epics(milestone_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int milestone_public_id: The ID of the Milestone. (required)
        :return: list[EpicSlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_milestone_epics_with_http_info(milestone_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_milestone_epics_with_http_info(milestone_public_id, **kwargs)  # noqa: E501
            return data

    def list_milestone_epics_with_http_info(self, milestone_public_id, **kwargs):  # noqa: E501
        """List Milestone Epics  # noqa: E501

        List all of the Epics within the Milestone.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_milestone_epics_with_http_info(milestone_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int milestone_public_id: The ID of the Milestone. (required)
        :return: list[EpicSlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['milestone_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_milestone_epics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'milestone_public_id' is set
        if ('milestone_public_id' not in params or
                params['milestone_public_id'] is None):
            raise ValueError("Missing the required parameter `milestone_public_id` when calling `list_milestone_epics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'milestone_public_id' in params:
            path_params['milestone-public-id'] = params['milestone_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/milestones/{milestone-public-id}/epics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EpicSlim]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_milestones(self, **kwargs):  # noqa: E501
        """List Milestones  # noqa: E501

        List Milestones returns a list of all Milestones and their attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_milestones(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Milestone]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_milestones_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_milestones_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_milestones_with_http_info(self, **kwargs):  # noqa: E501
        """List Milestones  # noqa: E501

        List Milestones returns a list of all Milestones and their attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_milestones_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Milestone]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_milestones" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/milestones', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Milestone]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_projects(self, **kwargs):  # noqa: E501
        """List Projects  # noqa: E501

        List Projects returns a list of all Projects and their attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_projects(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Project]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_projects_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_projects_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_projects_with_http_info(self, **kwargs):  # noqa: E501
        """List Projects  # noqa: E501

        List Projects returns a list of all Projects and their attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_projects_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Project]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_projects" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/projects', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Project]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_repositories(self, **kwargs):  # noqa: E501
        """List Repositories  # noqa: E501

        List Repositories returns a list of all Repositories and their attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_repositories(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Repository]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_repositories_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_repositories_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_repositories_with_http_info(self, **kwargs):  # noqa: E501
        """List Repositories  # noqa: E501

        List Repositories returns a list of all Repositories and their attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_repositories_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Repository]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_repositories" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/repositories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Repository]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_stories(self, body, project_public_id, **kwargs):  # noqa: E501
        """List Stories  # noqa: E501

        List Stories returns a list of all Stories in a selected Project and their attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_stories(body, project_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GetProjectStories body: (required)
        :param int project_public_id: The unique ID of the Project. (required)
        :return: list[StorySlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_stories_with_http_info(body, project_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_stories_with_http_info(body, project_public_id, **kwargs)  # noqa: E501
            return data

    def list_stories_with_http_info(self, body, project_public_id, **kwargs):  # noqa: E501
        """List Stories  # noqa: E501

        List Stories returns a list of all Stories in a selected Project and their attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_stories_with_http_info(body, project_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GetProjectStories body: (required)
        :param int project_public_id: The unique ID of the Project. (required)
        :return: list[StorySlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'project_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_stories" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `list_stories`")  # noqa: E501
        # verify the required parameter 'project_public_id' is set
        if ('project_public_id' not in params or
                params['project_public_id'] is None):
            raise ValueError("Missing the required parameter `project_public_id` when calling `list_stories`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_public_id' in params:
            path_params['project-public-id'] = params['project_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/projects/{project-public-id}/stories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[StorySlim]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_workflows(self, **kwargs):  # noqa: E501
        """List Workflows  # noqa: E501

        Returns a list of all Workflows in the Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_workflows(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Workflow]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_workflows_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_workflows_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_workflows_with_http_info(self, **kwargs):  # noqa: E501
        """List Workflows  # noqa: E501

        Returns a list of all Workflows in the Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_workflows_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Workflow]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_workflows" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/workflows', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Workflow]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search(self, body, **kwargs):  # noqa: E501
        """Search  # noqa: E501

        Search lets you search Epics and Stories based on desired parameters. Since ordering of the results can change over time (due to search ranking decay, new Epics and Stories being created), the `next` value from the previous response can be used as the path and query string for the next page to ensure stable ordering.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Search body: (required)
        :return: SearchResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.search_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def search_with_http_info(self, body, **kwargs):  # noqa: E501
        """Search  # noqa: E501

        Search lets you search Epics and Stories based on desired parameters. Since ordering of the results can change over time (due to search ranking decay, new Epics and Stories being created), the `next` value from the previous response can be used as the path and query string for the next page to ensure stable ordering.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Search body: (required)
        :return: SearchResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `search`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchResults',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_epics(self, body, **kwargs):  # noqa: E501
        """Search Epics  # noqa: E501

        Search Epics lets you search Epics based on desired parameters. Since ordering of stories can change over time (due to search ranking decay, new Epics being created), the `next` value from the previous response can be used as the path and query string for the next page to ensure stable ordering.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_epics(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Search body: (required)
        :return: EpicSearchResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_epics_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.search_epics_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def search_epics_with_http_info(self, body, **kwargs):  # noqa: E501
        """Search Epics  # noqa: E501

        Search Epics lets you search Epics based on desired parameters. Since ordering of stories can change over time (due to search ranking decay, new Epics being created), the `next` value from the previous response can be used as the path and query string for the next page to ensure stable ordering.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_epics_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Search body: (required)
        :return: EpicSearchResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_epics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `search_epics`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/search/epics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EpicSearchResults',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_stories(self, body, **kwargs):  # noqa: E501
        """Search Stories  # noqa: E501

        Search Stories lets you search Stories based on desired parameters. Since ordering of stories can change over time (due to search ranking decay, new stories being created), the `next` value from the previous response can be used as the path and query string for the next page to ensure stable ordering.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_stories(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Search body: (required)
        :return: StorySearchResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_stories_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.search_stories_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def search_stories_with_http_info(self, body, **kwargs):  # noqa: E501
        """Search Stories  # noqa: E501

        Search Stories lets you search Stories based on desired parameters. Since ordering of stories can change over time (due to search ranking decay, new stories being created), the `next` value from the previous response can be used as the path and query string for the next page to ensure stable ordering.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_stories_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Search body: (required)
        :return: StorySearchResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_stories" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `search_stories`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/search/stories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StorySearchResults',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_stories_old(self, body, **kwargs):  # noqa: E501
        """Search Stories (Old)  # noqa: E501

        Search Stories lets you search Stories based on desired parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_stories_old(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SearchStories body: (required)
        :return: list[StorySlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_stories_old_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.search_stories_old_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def search_stories_old_with_http_info(self, body, **kwargs):  # noqa: E501
        """Search Stories (Old)  # noqa: E501

        Search Stories lets you search Stories based on desired parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_stories_old_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SearchStories body: (required)
        :return: list[StorySlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_stories_old" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `search_stories_old`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/stories/search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[StorySlim]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def story_history(self, story_public_id, **kwargs):  # noqa: E501
        """Story History  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.story_history(story_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int story_public_id: The ID of the Story. (required)
        :return: list[History]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.story_history_with_http_info(story_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.story_history_with_http_info(story_public_id, **kwargs)  # noqa: E501
            return data

    def story_history_with_http_info(self, story_public_id, **kwargs):  # noqa: E501
        """Story History  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.story_history_with_http_info(story_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int story_public_id: The ID of the Story. (required)
        :return: list[History]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['story_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method story_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'story_public_id' is set
        if ('story_public_id' not in params or
                params['story_public_id'] is None):
            raise ValueError("Missing the required parameter `story_public_id` when calling `story_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'story_public_id' in params:
            path_params['story-public-id'] = params['story_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/stories/{story-public-id}/history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[History]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unlink_productboard_from_epic(self, epic_public_id, **kwargs):  # noqa: E501
        """Unlink Productboard from Epic  # noqa: E501

        This endpoint allows you to unlink a productboard epic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unlink_productboard_from_epic(epic_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int epic_public_id: The unique ID of the Epic. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unlink_productboard_from_epic_with_http_info(epic_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.unlink_productboard_from_epic_with_http_info(epic_public_id, **kwargs)  # noqa: E501
            return data

    def unlink_productboard_from_epic_with_http_info(self, epic_public_id, **kwargs):  # noqa: E501
        """Unlink Productboard from Epic  # noqa: E501

        This endpoint allows you to unlink a productboard epic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unlink_productboard_from_epic_with_http_info(epic_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int epic_public_id: The unique ID of the Epic. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['epic_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unlink_productboard_from_epic" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'epic_public_id' is set
        if ('epic_public_id' not in params or
                params['epic_public_id'] is None):
            raise ValueError("Missing the required parameter `epic_public_id` when calling `unlink_productboard_from_epic`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'epic_public_id' in params:
            path_params['epic-public-id'] = params['epic_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/epics/{epic-public-id}/unlink-productboard', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_category(self, body, category_public_id, **kwargs):  # noqa: E501
        """Update Category  # noqa: E501

        Update Category allows you to replace a Category name with another name. If you try to name a Category something that already exists, you will receive a 422 response.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_category(body, category_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateCategory body: (required)
        :param int category_public_id: The unique ID of the Category you wish to update. (required)
        :return: Category
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_category_with_http_info(body, category_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_category_with_http_info(body, category_public_id, **kwargs)  # noqa: E501
            return data

    def update_category_with_http_info(self, body, category_public_id, **kwargs):  # noqa: E501
        """Update Category  # noqa: E501

        Update Category allows you to replace a Category name with another name. If you try to name a Category something that already exists, you will receive a 422 response.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_category_with_http_info(body, category_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateCategory body: (required)
        :param int category_public_id: The unique ID of the Category you wish to update. (required)
        :return: Category
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'category_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_category" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_category`")  # noqa: E501
        # verify the required parameter 'category_public_id' is set
        if ('category_public_id' not in params or
                params['category_public_id'] is None):
            raise ValueError("Missing the required parameter `category_public_id` when calling `update_category`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'category_public_id' in params:
            path_params['category-public-id'] = params['category_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/categories/{category-public-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Category',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entity_template(self, body, entity_template_public_id, **kwargs):  # noqa: E501
        """Update Entity Template  # noqa: E501

        Update an entity template's name or its contents.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_entity_template(body, entity_template_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateEntityTemplate body: Request parameters for changing either a template's name or any of
  the attributes it is designed to pre-populate. (required)
        :param str entity_template_public_id: The unique ID of the template to be updated. (required)
        :return: EntityTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_entity_template_with_http_info(body, entity_template_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entity_template_with_http_info(body, entity_template_public_id, **kwargs)  # noqa: E501
            return data

    def update_entity_template_with_http_info(self, body, entity_template_public_id, **kwargs):  # noqa: E501
        """Update Entity Template  # noqa: E501

        Update an entity template's name or its contents.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_entity_template_with_http_info(body, entity_template_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateEntityTemplate body: Request parameters for changing either a template's name or any of
  the attributes it is designed to pre-populate. (required)
        :param str entity_template_public_id: The unique ID of the template to be updated. (required)
        :return: EntityTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'entity_template_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entity_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_entity_template`")  # noqa: E501
        # verify the required parameter 'entity_template_public_id' is set
        if ('entity_template_public_id' not in params or
                params['entity_template_public_id'] is None):
            raise ValueError("Missing the required parameter `entity_template_public_id` when calling `update_entity_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entity_template_public_id' in params:
            path_params['entity-template-public-id'] = params['entity_template_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/entity-templates/{entity-template-public-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EntityTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_epic(self, body, epic_public_id, **kwargs):  # noqa: E501
        """Update Epic  # noqa: E501

        Update Epic can be used to update numerous fields in the Epic. The only required parameter is Epic ID, which can be found in the Shortcut UI.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_epic(body, epic_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateEpic body: (required)
        :param int epic_public_id: The unique ID of the Epic. (required)
        :return: Epic
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_epic_with_http_info(body, epic_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_epic_with_http_info(body, epic_public_id, **kwargs)  # noqa: E501
            return data

    def update_epic_with_http_info(self, body, epic_public_id, **kwargs):  # noqa: E501
        """Update Epic  # noqa: E501

        Update Epic can be used to update numerous fields in the Epic. The only required parameter is Epic ID, which can be found in the Shortcut UI.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_epic_with_http_info(body, epic_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateEpic body: (required)
        :param int epic_public_id: The unique ID of the Epic. (required)
        :return: Epic
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'epic_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_epic" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_epic`")  # noqa: E501
        # verify the required parameter 'epic_public_id' is set
        if ('epic_public_id' not in params or
                params['epic_public_id'] is None):
            raise ValueError("Missing the required parameter `epic_public_id` when calling `update_epic`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'epic_public_id' in params:
            path_params['epic-public-id'] = params['epic_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/epics/{epic-public-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Epic',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_epic_comment(self, body, epic_public_id, comment_public_id, **kwargs):  # noqa: E501
        """Update Epic Comment  # noqa: E501

        This endpoint allows you to update a threaded Comment on an Epic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_epic_comment(body, epic_public_id, comment_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateComment body: (required)
        :param int epic_public_id: The ID of the associated Epic. (required)
        :param int comment_public_id: The ID of the Comment. (required)
        :return: ThreadedComment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_epic_comment_with_http_info(body, epic_public_id, comment_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_epic_comment_with_http_info(body, epic_public_id, comment_public_id, **kwargs)  # noqa: E501
            return data

    def update_epic_comment_with_http_info(self, body, epic_public_id, comment_public_id, **kwargs):  # noqa: E501
        """Update Epic Comment  # noqa: E501

        This endpoint allows you to update a threaded Comment on an Epic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_epic_comment_with_http_info(body, epic_public_id, comment_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateComment body: (required)
        :param int epic_public_id: The ID of the associated Epic. (required)
        :param int comment_public_id: The ID of the Comment. (required)
        :return: ThreadedComment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'epic_public_id', 'comment_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_epic_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_epic_comment`")  # noqa: E501
        # verify the required parameter 'epic_public_id' is set
        if ('epic_public_id' not in params or
                params['epic_public_id'] is None):
            raise ValueError("Missing the required parameter `epic_public_id` when calling `update_epic_comment`")  # noqa: E501
        # verify the required parameter 'comment_public_id' is set
        if ('comment_public_id' not in params or
                params['comment_public_id'] is None):
            raise ValueError("Missing the required parameter `comment_public_id` when calling `update_epic_comment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'epic_public_id' in params:
            path_params['epic-public-id'] = params['epic_public_id']  # noqa: E501
        if 'comment_public_id' in params:
            path_params['comment-public-id'] = params['comment_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/epics/{epic-public-id}/comments/{comment-public-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ThreadedComment',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_file(self, body, file_public_id, **kwargs):  # noqa: E501
        """Update File  # noqa: E501

        Update File updates the properties of an UploadedFile (but not its content).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_file(body, file_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateFile body: (required)
        :param int file_public_id: The unique ID assigned to the file in Shortcut. (required)
        :return: UploadedFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_file_with_http_info(body, file_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_file_with_http_info(body, file_public_id, **kwargs)  # noqa: E501
            return data

    def update_file_with_http_info(self, body, file_public_id, **kwargs):  # noqa: E501
        """Update File  # noqa: E501

        Update File updates the properties of an UploadedFile (but not its content).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_file_with_http_info(body, file_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateFile body: (required)
        :param int file_public_id: The unique ID assigned to the file in Shortcut. (required)
        :return: UploadedFile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'file_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_file`")  # noqa: E501
        # verify the required parameter 'file_public_id' is set
        if ('file_public_id' not in params or
                params['file_public_id'] is None):
            raise ValueError("Missing the required parameter `file_public_id` when calling `update_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_public_id' in params:
            path_params['file-public-id'] = params['file_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/files/{file-public-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UploadedFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_group(self, body, group_public_id, **kwargs):  # noqa: E501
        """Update Group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_group(body, group_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateGroup body: (required)
        :param str group_public_id: The unique ID of the Group. (required)
        :return: Group
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_group_with_http_info(body, group_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_group_with_http_info(body, group_public_id, **kwargs)  # noqa: E501
            return data

    def update_group_with_http_info(self, body, group_public_id, **kwargs):  # noqa: E501
        """Update Group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_group_with_http_info(body, group_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateGroup body: (required)
        :param str group_public_id: The unique ID of the Group. (required)
        :return: Group
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'group_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_group`")  # noqa: E501
        # verify the required parameter 'group_public_id' is set
        if ('group_public_id' not in params or
                params['group_public_id'] is None):
            raise ValueError("Missing the required parameter `group_public_id` when calling `update_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_public_id' in params:
            path_params['group-public-id'] = params['group_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/groups/{group-public-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Group',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_iteration(self, body, iteration_public_id, **kwargs):  # noqa: E501
        """Update Iteration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_iteration(body, iteration_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateIteration body: (required)
        :param int iteration_public_id: The unique ID of the Iteration. (required)
        :return: Iteration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_iteration_with_http_info(body, iteration_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_iteration_with_http_info(body, iteration_public_id, **kwargs)  # noqa: E501
            return data

    def update_iteration_with_http_info(self, body, iteration_public_id, **kwargs):  # noqa: E501
        """Update Iteration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_iteration_with_http_info(body, iteration_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateIteration body: (required)
        :param int iteration_public_id: The unique ID of the Iteration. (required)
        :return: Iteration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'iteration_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_iteration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_iteration`")  # noqa: E501
        # verify the required parameter 'iteration_public_id' is set
        if ('iteration_public_id' not in params or
                params['iteration_public_id'] is None):
            raise ValueError("Missing the required parameter `iteration_public_id` when calling `update_iteration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'iteration_public_id' in params:
            path_params['iteration-public-id'] = params['iteration_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/iterations/{iteration-public-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Iteration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_label(self, body, label_public_id, **kwargs):  # noqa: E501
        """Update Label  # noqa: E501

        Update Label allows you to replace a Label name with another name. If you try to name a Label something that already exists, you will receive a 422 response.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_label(body, label_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateLabel body: (required)
        :param int label_public_id: The unique ID of the Label you wish to update. (required)
        :return: Label
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_label_with_http_info(body, label_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_label_with_http_info(body, label_public_id, **kwargs)  # noqa: E501
            return data

    def update_label_with_http_info(self, body, label_public_id, **kwargs):  # noqa: E501
        """Update Label  # noqa: E501

        Update Label allows you to replace a Label name with another name. If you try to name a Label something that already exists, you will receive a 422 response.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_label_with_http_info(body, label_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateLabel body: (required)
        :param int label_public_id: The unique ID of the Label you wish to update. (required)
        :return: Label
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'label_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_label" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_label`")  # noqa: E501
        # verify the required parameter 'label_public_id' is set
        if ('label_public_id' not in params or
                params['label_public_id'] is None):
            raise ValueError("Missing the required parameter `label_public_id` when calling `update_label`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'label_public_id' in params:
            path_params['label-public-id'] = params['label_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/labels/{label-public-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Label',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_linked_file(self, body, linked_file_public_id, **kwargs):  # noqa: E501
        """Update Linked File  # noqa: E501

        Updated Linked File allows you to update properties of a previously attached Linked-File.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_linked_file(body, linked_file_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateLinkedFile body: (required)
        :param int linked_file_public_id: The unique identifier of the linked file. (required)
        :return: LinkedFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_linked_file_with_http_info(body, linked_file_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_linked_file_with_http_info(body, linked_file_public_id, **kwargs)  # noqa: E501
            return data

    def update_linked_file_with_http_info(self, body, linked_file_public_id, **kwargs):  # noqa: E501
        """Update Linked File  # noqa: E501

        Updated Linked File allows you to update properties of a previously attached Linked-File.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_linked_file_with_http_info(body, linked_file_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateLinkedFile body: (required)
        :param int linked_file_public_id: The unique identifier of the linked file. (required)
        :return: LinkedFile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'linked_file_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_linked_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_linked_file`")  # noqa: E501
        # verify the required parameter 'linked_file_public_id' is set
        if ('linked_file_public_id' not in params or
                params['linked_file_public_id'] is None):
            raise ValueError("Missing the required parameter `linked_file_public_id` when calling `update_linked_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'linked_file_public_id' in params:
            path_params['linked-file-public-id'] = params['linked_file_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/linked-files/{linked-file-public-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LinkedFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_milestone(self, body, milestone_public_id, **kwargs):  # noqa: E501
        """Update Milestone  # noqa: E501

        Update Milestone can be used to update Milestone properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_milestone(body, milestone_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateMilestone body: (required)
        :param int milestone_public_id: The ID of the Milestone. (required)
        :return: Milestone
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_milestone_with_http_info(body, milestone_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_milestone_with_http_info(body, milestone_public_id, **kwargs)  # noqa: E501
            return data

    def update_milestone_with_http_info(self, body, milestone_public_id, **kwargs):  # noqa: E501
        """Update Milestone  # noqa: E501

        Update Milestone can be used to update Milestone properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_milestone_with_http_info(body, milestone_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateMilestone body: (required)
        :param int milestone_public_id: The ID of the Milestone. (required)
        :return: Milestone
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'milestone_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_milestone" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_milestone`")  # noqa: E501
        # verify the required parameter 'milestone_public_id' is set
        if ('milestone_public_id' not in params or
                params['milestone_public_id'] is None):
            raise ValueError("Missing the required parameter `milestone_public_id` when calling `update_milestone`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'milestone_public_id' in params:
            path_params['milestone-public-id'] = params['milestone_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/milestones/{milestone-public-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Milestone',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_multiple_stories(self, body, **kwargs):  # noqa: E501
        """Update Multiple Stories  # noqa: E501

        Update Multiple Stories allows you to make changes to numerous stories at once.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_multiple_stories(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateStories body: (required)
        :return: list[StorySlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_multiple_stories_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_multiple_stories_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def update_multiple_stories_with_http_info(self, body, **kwargs):  # noqa: E501
        """Update Multiple Stories  # noqa: E501

        Update Multiple Stories allows you to make changes to numerous stories at once.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_multiple_stories_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateStories body: (required)
        :return: list[StorySlim]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_multiple_stories" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_multiple_stories`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/stories/bulk', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[StorySlim]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_project(self, body, project_public_id, **kwargs):  # noqa: E501
        """Update Project  # noqa: E501

        Update Project can be used to change properties of a Project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_project(body, project_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateProject body: (required)
        :param int project_public_id: The unique ID of the Project. (required)
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_project_with_http_info(body, project_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_project_with_http_info(body, project_public_id, **kwargs)  # noqa: E501
            return data

    def update_project_with_http_info(self, body, project_public_id, **kwargs):  # noqa: E501
        """Update Project  # noqa: E501

        Update Project can be used to change properties of a Project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_project_with_http_info(body, project_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateProject body: (required)
        :param int project_public_id: The unique ID of the Project. (required)
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'project_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_project`")  # noqa: E501
        # verify the required parameter 'project_public_id' is set
        if ('project_public_id' not in params or
                params['project_public_id'] is None):
            raise ValueError("Missing the required parameter `project_public_id` when calling `update_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_public_id' in params:
            path_params['project-public-id'] = params['project_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/projects/{project-public-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Project',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_story(self, body, story_public_id, **kwargs):  # noqa: E501
        """Update Story  # noqa: E501

        Update Story can be used to update Story properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_story(body, story_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateStory body: (required)
        :param int story_public_id: The unique identifier of this story. (required)
        :return: Story
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_story_with_http_info(body, story_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_story_with_http_info(body, story_public_id, **kwargs)  # noqa: E501
            return data

    def update_story_with_http_info(self, body, story_public_id, **kwargs):  # noqa: E501
        """Update Story  # noqa: E501

        Update Story can be used to update Story properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_story_with_http_info(body, story_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateStory body: (required)
        :param int story_public_id: The unique identifier of this story. (required)
        :return: Story
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'story_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_story" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_story`")  # noqa: E501
        # verify the required parameter 'story_public_id' is set
        if ('story_public_id' not in params or
                params['story_public_id'] is None):
            raise ValueError("Missing the required parameter `story_public_id` when calling `update_story`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'story_public_id' in params:
            path_params['story-public-id'] = params['story_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/stories/{story-public-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Story',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_story_comment(self, body, story_public_id, comment_public_id, **kwargs):  # noqa: E501
        """Update Story Comment  # noqa: E501

        Update Comment replaces the text of the existing Comment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_story_comment(body, story_public_id, comment_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateStoryComment body: (required)
        :param int story_public_id: The ID of the Story that the Comment is in. (required)
        :param int comment_public_id: The ID of the Comment (required)
        :return: StoryComment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_story_comment_with_http_info(body, story_public_id, comment_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_story_comment_with_http_info(body, story_public_id, comment_public_id, **kwargs)  # noqa: E501
            return data

    def update_story_comment_with_http_info(self, body, story_public_id, comment_public_id, **kwargs):  # noqa: E501
        """Update Story Comment  # noqa: E501

        Update Comment replaces the text of the existing Comment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_story_comment_with_http_info(body, story_public_id, comment_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateStoryComment body: (required)
        :param int story_public_id: The ID of the Story that the Comment is in. (required)
        :param int comment_public_id: The ID of the Comment (required)
        :return: StoryComment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'story_public_id', 'comment_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_story_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_story_comment`")  # noqa: E501
        # verify the required parameter 'story_public_id' is set
        if ('story_public_id' not in params or
                params['story_public_id'] is None):
            raise ValueError("Missing the required parameter `story_public_id` when calling `update_story_comment`")  # noqa: E501
        # verify the required parameter 'comment_public_id' is set
        if ('comment_public_id' not in params or
                params['comment_public_id'] is None):
            raise ValueError("Missing the required parameter `comment_public_id` when calling `update_story_comment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'story_public_id' in params:
            path_params['story-public-id'] = params['story_public_id']  # noqa: E501
        if 'comment_public_id' in params:
            path_params['comment-public-id'] = params['comment_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/stories/{story-public-id}/comments/{comment-public-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StoryComment',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_story_link(self, body, story_link_public_id, **kwargs):  # noqa: E501
        """Update Story Link  # noqa: E501

        Updates the stories and/or the relationship for the given Story Link.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_story_link(body, story_link_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateStoryLink body: (required)
        :param int story_link_public_id: The unique ID of the Story Link. (required)
        :return: StoryLink
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_story_link_with_http_info(body, story_link_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_story_link_with_http_info(body, story_link_public_id, **kwargs)  # noqa: E501
            return data

    def update_story_link_with_http_info(self, body, story_link_public_id, **kwargs):  # noqa: E501
        """Update Story Link  # noqa: E501

        Updates the stories and/or the relationship for the given Story Link.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_story_link_with_http_info(body, story_link_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateStoryLink body: (required)
        :param int story_link_public_id: The unique ID of the Story Link. (required)
        :return: StoryLink
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'story_link_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_story_link" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_story_link`")  # noqa: E501
        # verify the required parameter 'story_link_public_id' is set
        if ('story_link_public_id' not in params or
                params['story_link_public_id'] is None):
            raise ValueError("Missing the required parameter `story_link_public_id` when calling `update_story_link`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'story_link_public_id' in params:
            path_params['story-link-public-id'] = params['story_link_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/story-links/{story-link-public-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StoryLink',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_task(self, body, story_public_id, task_public_id, **kwargs):  # noqa: E501
        """Update Task  # noqa: E501

        Update Task can be used to update Task properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_task(body, story_public_id, task_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateTask body: (required)
        :param int story_public_id: The unique identifier of the parent Story. (required)
        :param int task_public_id: The unique identifier of the Task you wish to update. (required)
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_task_with_http_info(body, story_public_id, task_public_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_task_with_http_info(body, story_public_id, task_public_id, **kwargs)  # noqa: E501
            return data

    def update_task_with_http_info(self, body, story_public_id, task_public_id, **kwargs):  # noqa: E501
        """Update Task  # noqa: E501

        Update Task can be used to update Task properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_task_with_http_info(body, story_public_id, task_public_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateTask body: (required)
        :param int story_public_id: The unique identifier of the parent Story. (required)
        :param int task_public_id: The unique identifier of the Task you wish to update. (required)
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'story_public_id', 'task_public_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_task`")  # noqa: E501
        # verify the required parameter 'story_public_id' is set
        if ('story_public_id' not in params or
                params['story_public_id'] is None):
            raise ValueError("Missing the required parameter `story_public_id` when calling `update_task`")  # noqa: E501
        # verify the required parameter 'task_public_id' is set
        if ('task_public_id' not in params or
                params['task_public_id'] is None):
            raise ValueError("Missing the required parameter `task_public_id` when calling `update_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'story_public_id' in params:
            path_params['story-public-id'] = params['story_public_id']  # noqa: E501
        if 'task_public_id' in params:
            path_params['task-public-id'] = params['task_public_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/stories/{story-public-id}/tasks/{task-public-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Task',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_files(self, story_id, file0, file1, file2, file3, **kwargs):  # noqa: E501
        """Upload Files  # noqa: E501

        Upload Files uploads one or many files and optionally associates them with a story.    Use the multipart/form-data content-type to upload.    Each `file` key should contain a separate file.    Each UploadedFile's name comes from the Content-Disposition header \"filename\" directive for that field.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_files(story_id, file0, file1, file2, file3, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int story_id: (required)
        :param str file0: (required)
        :param str file1: (required)
        :param str file2: (required)
        :param str file3: (required)
        :return: list[UploadedFile]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upload_files_with_http_info(story_id, file0, file1, file2, file3, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_files_with_http_info(story_id, file0, file1, file2, file3, **kwargs)  # noqa: E501
            return data

    def upload_files_with_http_info(self, story_id, file0, file1, file2, file3, **kwargs):  # noqa: E501
        """Upload Files  # noqa: E501

        Upload Files uploads one or many files and optionally associates them with a story.    Use the multipart/form-data content-type to upload.    Each `file` key should contain a separate file.    Each UploadedFile's name comes from the Content-Disposition header \"filename\" directive for that field.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_files_with_http_info(story_id, file0, file1, file2, file3, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int story_id: (required)
        :param str file0: (required)
        :param str file1: (required)
        :param str file2: (required)
        :param str file3: (required)
        :return: list[UploadedFile]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['story_id', 'file0', 'file1', 'file2', 'file3']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_files" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'story_id' is set
        if ('story_id' not in params or
                params['story_id'] is None):
            raise ValueError("Missing the required parameter `story_id` when calling `upload_files`")  # noqa: E501
        # verify the required parameter 'file0' is set
        if ('file0' not in params or
                params['file0'] is None):
            raise ValueError("Missing the required parameter `file0` when calling `upload_files`")  # noqa: E501
        # verify the required parameter 'file1' is set
        if ('file1' not in params or
                params['file1'] is None):
            raise ValueError("Missing the required parameter `file1` when calling `upload_files`")  # noqa: E501
        # verify the required parameter 'file2' is set
        if ('file2' not in params or
                params['file2'] is None):
            raise ValueError("Missing the required parameter `file2` when calling `upload_files`")  # noqa: E501
        # verify the required parameter 'file3' is set
        if ('file3' not in params or
                params['file3'] is None):
            raise ValueError("Missing the required parameter `file3` when calling `upload_files`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'story_id' in params:
            form_params.append(('story_id', params['story_id']))  # noqa: E501
        if 'file0' in params:
            local_var_files['file0'] = params['file0']  # noqa: E501
        if 'file1' in params:
            local_var_files['file1'] = params['file1']  # noqa: E501
        if 'file2' in params:
            local_var_files['file2'] = params['file2']  # noqa: E501
        if 'file3' in params:
            local_var_files['file3'] = params['file3']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/files', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[UploadedFile]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
